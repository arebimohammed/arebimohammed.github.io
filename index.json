[{"categories":["Logistic Regression","Tutorial","Machine Learning"],"content":"All you need to know","date":"2020-07-09","objectID":"/logistic-regression/","tags":["blogging","data science","machine learning","logistic regression","python"],"title":"Logistic Regression","uri":"/logistic-regression/"},{"categories":["Logistic Regression","Tutorial","Machine Learning"],"content":"Introduction The logistic model (or logit model) in statistics is a statistical model that represents the probability of an event occurring by making the log-odds for the event a linear combination of one or more independent variables. Logistic regression is another approach borrowed from statistics by machine learning. It is the go-to strategy for binary classification problems (problems with two classes) even though it is a regression algorithm (predicts probabilities, more on that later). For example, To predict whether an email is spam (1) or not (0) Whether the tumor is malignant (1) or not (0) This post will discuss the logistic regression algorithm for machine learning. What’s the Problem with Linear Regression for Classification? The linear regression model is effective for regression but ineffective for classification. Why is this the case? If you have two classes, you may label one with 0 and the other with 1 and use linear regression. It works technically, and most linear model programmes will generate weights for you. However, there are a couple issues with this approach: A linear model does not produce probabilities, but rather treats the classes as integers (0 and 1) and finds the optimum hyperplane (for a single feature, a line) that minimises the distances between the points and the hyperplane. As a result, it just interpolates between the points and cannot be interpreted as probabilities. A linear model will also extrapolate numbers below zero and above one. This is a promising hint that there may be a more intelligent method to classification. Linear models are not applicable to multi-class classification issues. The next class would have to be labelled with 2, then 3, and so on. Although the classes may not be in any meaningful order, the linear model would impose an odd structure on the relationship between the features and your class predictions. The higher the value of a positive-weighted feature, the more it contributes to the prediction of a class with a higher number, even if classes with similar numbers are not closer than other classes. Because the predicted outcome is a linear interpolation between points rather than a probability, there is no meaningful threshold at which one class can be distinguished from the other. A decent example of this problem may be seen on Stackoverflow. So what can be a solution to classification problems, well there are many but one solution is logistic regression, here come the logistic function (or the sigmoid function) ","date":"2020-07-09","objectID":"/logistic-regression/:0:1","tags":["blogging","data science","machine learning","logistic regression","python"],"title":"Logistic Regression","uri":"/logistic-regression/"},{"categories":["Logistic Regression","Tutorial","Machine Learning"],"content":"The Logistic Function Logistic regression is named after the logistic function, which is at the heart of the algorithm. The logistic function, also known as the sigmoid function, was devised by statisticians to characterise the characteristics of rapid population expansion in ecology that exceeds the carrying capacity of the ecosystem (check here). It’s an S-shaped curve that can transfer any real-valued integer to a value between 0 and 1, but never exactly between those bounds. $$f(z) = \\frac{1}{1 + e^{-z}}$$ Where $e$ is the natural logarithm base (Euler’s number) and z is the actual numerical value to be transformed. Below we can see the logistic/sigmoid function applied to a range of numbers between -10 and 10 transformed into the range 0 and 1 using the logistic function. Now that we’ve defined the logistic function, let’s look at how it’s employed in logistic regression. ","date":"2020-07-09","objectID":"/logistic-regression/:0:2","tags":["blogging","data science","machine learning","logistic regression","python"],"title":"Logistic Regression","uri":"/logistic-regression/"},{"categories":["Logistic Regression","Tutorial","Machine Learning"],"content":"Logistic Regression Algorithm Representation Logistic regression, like linear regression, uses an equation as its representation. The transition from linear regression to logistic regression is rather simple. We used a linear equation to model the link between the outcome and the features in the linear regression model: We prefer probabilities between 0 and 1 for classification, so we wrap the right side of the equation in the logistic function. This constrains the output to only accept values between 0 and 1. To predict the output value ($y$), the input values ($X$) are linearly combined using weights or coefficient values (referred to as the Greek capital letter Beta). The coefficients in the equation are the real representation of the model that you would store in memory or in a file. ","date":"2020-07-09","objectID":"/logistic-regression/:0:3","tags":["blogging","data science","machine learning","logistic regression","python"],"title":"Logistic Regression","uri":"/logistic-regression/"},{"categories":["Logistic Regression","Tutorial","Machine Learning"],"content":"Why Logistic Regression is Regression not Classification Simply put, logistic regression predicts probabilities which are continous values (i.e., regression).The probability of the default class is modelled using logistic regression (e.g. the first class). For example, if we are modelling people’s gender based on their height as male or female, the first class may be male, and the logistic regression model could be expressed as the probability of male given a person’s height, or more formally: In other words, we are modelling the probability that an input (X) belongs to the default class (Y=1); we can express this formally as: Probability Prediction It should be noted that in order to make a probability prediction, the probability prediction must be translated into a binary value (0 or 1). More on this later when we discuss making predictions. Logistic regression is a linear method, however the logistic function is used to alter the predictions. As a result, we can no longer understand the predictions as a linear combination of the inputs, as we can with linear regression. To continue from above, the model can be described as: We can transform the previous equation as follows (remembering that we may eliminate the $e$ (exp) from one side by adding a natural logarithm ($ln$) to the other): This is beneficial because we can see that the output on the right is linear again (exactly like linear regression), and the input on the left is a log of the likelihood of the default class. This ratio on the left is known as the default class’s odds (it’s historical that we use odds rather than probabilities; for example, odds are used in boxing rather than probabilities). Odds are calculated as a ratio of the event’s likelihood divided by the event’s probability of not occurring. For example, 0.5/(1-0.5) which has the odds of 1. So we could instead write: Because the odds are log transformed, the left hand side is referred to as the log-odds or the probit. Although different types of functions can be used for the transform, the transform that relates the linear regression equation to the probabilities is commonly referred to as the link function, for example, the probit link function. We can reposition the exponent to the right and write it as: All of this helps us understand that the model is still a linear combination of the inputs, but that this linear combination is related to the default class’s log-odds. ","date":"2020-07-09","objectID":"/logistic-regression/:0:4","tags":["blogging","data science","machine learning","logistic regression","python"],"title":"Logistic Regression","uri":"/logistic-regression/"},{"categories":["Logistic Regression","Tutorial","Machine Learning"],"content":"Learning the Logistic Regression Model Parameters The logistic regression algorithm’s coefficients must be estimated using your training data. This is typically accomplished through the use of maximum-likelihood estimation (gradient-descent can also be used, article on that in the future) Although it does make assumptions about the distribution of your data, maximum-likelihood estimation (MLE) is a frequent learning method utilised by a variety of machine learning algorithms. The best coefficients would result in a model that predicted a value very close to 1 (for example, male) for the default class and a value very close to 0 (for example, female) for the other class. The idea behind maximum-likelihood logistic regression is that a search algorithm seeks coefficient values that minimise the error (see The loss function) between the probabilities predicted by the model and those in the data (e.g. probability of 1 if the data is the primary class). It is sufficient to state that a minimization algorithm is utilised to optimise the coefficient values for the training data. The loss function and MLE So, to learn the coefficients ($\\beta$) of a logistic regression model, we need to define a cost function. MLE is a specific type of probability model estimation, where the loss/objective function is the log likelihood (or minimizing the negative log likelihood) denoted by $\\mathcal{L}$. Suppose we have a set of experimental observations: and a class of distributions $p(x;\\theta)$, where $\\theta$ is a set of parameters on which the form of $p$ depends. The MLE for the distribution from which the dataset has been extracted is defined as the one which maximizes the quantity as $\\theta$ varies. Therefore, in the hypothesis that variables are i.i.d. (Independent and identically distributed) the best value for $\\theta$ will be given by Because multiplication easily overflows/underflows, the equivalent expression is frequently used instead of this one Let’s look at how this method can be used to construct the log-likelihood loss function (also known as cross-entropy). Surprisingly, while training machine learning algorithms, the maximum likelihood estimation method can be used to create loss functions. In fact, one can imagine working in a scenario in which a dataset with specific statistical qualities is generated, and then construct a loss function that takes those properties into account automatically. Log likelihood or cross-entropy is the mainly used loss function in classification problems, namely problems in which the underlying distribution has a discrete set of output values. Just as an example one can imagine a Bernoulli distribution, which has two outputs, one having probability $p$ and the other $(1−p)$ of being extracted. The negative log likelihood is defined as and in information theory it quantifies the average number of bits needed to identify an event drawn from a set if a coding scheme used for the set is optimized for an estimated probability distribution $q$, rather than the true distribution $p$. This quantity can also be derived using MLE. Suppose data extracted according to a distribution $p(x)$ and an estimated distribution $q(x)$. Let’s also define the class of estimated probability distributions $\\hat{y} = \\hat{g}(x; \\vec{\\theta})$. Then the optimal parameters are obtained minimizing where $\\Omega$ is the sample space on which the probability space is defined. This way negative log likelihood is recovered as well. ","date":"2020-07-09","objectID":"/logistic-regression/:0:5","tags":["blogging","data science","machine learning","logistic regression","python"],"title":"Logistic Regression","uri":"/logistic-regression/"},{"categories":["Logistic Regression","Tutorial","Machine Learning"],"content":"Prediction with Logistic Regression Predictions with a logistic regression model are as easy as plugging numbers into the logistic regression equation and computing the result. Let’s put this into context with an example. Imagine that we had a model that can determine a person’s gender based on their height (completely fictitious). Is the person male or female given a height of 192cm? Assuming we now know (learned) the coefficients $\\beta_{0} = -70$ and $\\beta_{1} = 0.4$. Using the aforementioned equation, we can determine the probability of a male given a height of 165cm, or $P(male|height=165)$. Or a very low probability of that the person is a male. In practise, the probabilities can be used immediately. Because this is a classification problem and we want a useful result, we can convert the probabilities to a binary class value, such as ","date":"2020-07-09","objectID":"/logistic-regression/:0:6","tags":["blogging","data science","machine learning","logistic regression","python"],"title":"Logistic Regression","uri":"/logistic-regression/"},{"categories":["Logistic Regression","Tutorial","Machine Learning"],"content":"Using Logistic Regression on a dataset I’ll be using the Rain In Australia dataset found in kaggle. The dataset contains information regarding daily weather measurements from a variety of sites in Australia and the aim is to predict whether it will rain the next day or not (Yes or No), which is a binary classification problem that is well suited for logistic regression. I implemented Logistic Regression with Python and Scikit-Learn using its LogisticRegression class. All code can be found in my github. I first import the libraries and load the dataset. import pandas as pd import numpy as np import matplotlib.pyplot as plt import seaborn as sns from sklearn.linear_model import LogisticRegression from sklearn.model_selection import train_test_split from sklearn.preprocessing import MinMaxScaler from sklearn.metrics import accuracy_score from sklearn.metrics import confusion_matrix from sklearn.metrics import classification_report import category_encoders as ce df = pd.read_csv(\"./data/weatherAUS.csv\") Then I conduct some Exploratory Data Analysis (EDA), some cleaning and data preparation for modelling Dataset shape df.shape (145460, 23) Preview the dataset df.head() Date Location MinTemp MaxTemp Rainfall Evaporation Sunshine WindGustDir WindGustSpeed WindDir9am ... Humidity9am Humidity3pm Pressure9am Pressure3pm Cloud9am Cloud3pm Temp9am Temp3pm RainToday RainTomorrow 0 2008-12-01 Albury 13.4 22.9 0.6 NaN NaN W 44.0 W ... 71.0 22.0 1007.7 1007.1 8.0 NaN 16.9 21.8 No No 1 2008-12-02 Albury 7.4 25.1 0.0 NaN NaN WNW 44.0 NNW ... 44.0 25.0 1010.6 1007.8 NaN NaN 17.2 24.3 No No 2 2008-12-03 Albury 12.9 25.7 0.0 NaN NaN WSW 46.0 W ... 38.0 30.0 1007.6 1008.7 NaN 2.0 21.0 23.2 No No 3 2008-12-04 Albury 9.2 28.0 0.0 NaN NaN NE 24.0 SE ... 45.0 16.0 1017.6 1012.8 NaN NaN 18.1 26.5 No No 4 2008-12-05 Albury 17.5 32.3 1.0 NaN NaN W 41.0 ENE ... 82.0 33.0 1010.8 1006.0 7.0 8.0 17.8 29.7 No No 5 rows × 23 columns Get column names for col in df.columns.values.tolist(): print(col+\",\", end=' ') Date, Location, MinTemp, MaxTemp, Rainfall, Evaporation, Sunshine, WindGustDir, WindGustSpeed, WindDir9am, WindDir3pm, WindSpeed9am, WindSpeed3pm, Humidity9am, Humidity3pm, Pressure9am, Pressure3pm, Cloud9am, Cloud3pm, Temp9am, Temp3pm, RainToday, RainTomorrow View summary of dataset df.info() \u003cclass 'pandas.core.frame.DataFrame'\u003e RangeIndex: 145460 entries, 0 to 145459 Data columns (total 23 columns): # Column Non-Null Count Dtype --- ------ -------------- ----- 0 Date 145460 non-null object 1 Location 145460 non-null object 2 MinTemp 143975 non-null float64 3 MaxTemp 144199 non-null float64 4 Rainfall 142199 non-null float64 5 Evaporation 82670 non-null float64 6 Sunshine 75625 non-null float64 7 WindGustDir 135134 non-null object 8 WindGustSpeed 135197 non-null float64 9 WindDir9am 134894 non-null object 10 WindDir3pm 141232 non-null object 11 WindSpeed9am 143693 non-null float64 12 WindSpeed3pm 142398 non-null float64 13 Humidity9am 142806 non-null float64 14 Humidity3pm 140953 non-null float64 15 Pressure9am 130395 non-null float64 16 Pressure3pm 130432 non-null float64 17 Cloud9am 89572 non-null float64 18 Cloud3pm 86102 non-null float64 19 Temp9am 143693 non-null float64 20 Temp3pm 141851 non-null float64 21 RainToday 142199 non-null object 22 RainTomorrow 142193 non-null object dtypes: float64(16), object(7) memory usage: 25.5+ MB We can see that the dataset contains mixture of categorical and numerical variables. Categorical variables have data type object. Numerical variables have data type float64. Also, there are some missing values in the dataset. We will explore it later. View statistical properties of dataset df.describe() MinTemp MaxTemp Rainfall Evaporation Sunshine WindGustSpeed WindSpeed9am WindSpeed3pm Humidity9am Humidity3pm Pressure9am Pressure3pm Cloud9am Cloud3pm Temp9am Temp3pm count 143975.000000 144199.000000 142199.000000 82670.000000 75625.000000 135197.000000 143693.000000 142398.000000 142806.000000 140953.000000 130395.000","date":"2020-07-09","objectID":"/logistic-regression/:0:7","tags":["blogging","data science","machine learning","logistic regression","python"],"title":"Logistic Regression","uri":"/logistic-regression/"},{"categories":["Logistic Regression","Tutorial","Machine Learning"],"content":"Multivariate Analysis An important step in EDA is to discover patterns and relationships between variables in the dataset. I will use heat map and pair plot to discover the patterns and relationships in the dataset. First of all, I will draw a heat map. correlation = df.corr() plt.figure(figsize=(16,12)) plt.title('Correlation Heatmap of Rain in Australia Dataset') ax = sns.heatmap(correlation, square=True, annot=True, fmt='.2f', linecolor='white') ax.set_xticklabels(ax.get_xticklabels(), rotation=90) ax.set_yticklabels(ax.get_yticklabels(), rotation=30) plt.show() Interpretation From the above correlation heat map, we can conclude that : MinTemp and MaxTemp variables are highly positively correlated (correlation coefficient = 0.74). MinTemp and Temp3pm variables are also highly positively correlated (correlation coefficient = 0.71). MinTemp and Temp9am variables are strongly positively correlated (correlation coefficient = 0.90). MaxTemp and Temp9am variables are strongly positively correlated (correlation coefficient = 0.89). MaxTemp and Temp3pm variables are also strongly positively correlated (correlation coefficient = 0.98). WindGustSpeed and WindSpeed3pm variables are highly positively correlated (correlation coefficient = 0.69). Pressure9am and Pressure3pm variables are strongly positively correlated (correlation coefficient = 0.96). Temp9am and Temp3pm variables are strongly positively correlated (correlation coefficient = 0.86). Pair Plot First of all, I will define extract the variables which are highly positively correlated. num_var = ['MinTemp', 'MaxTemp', 'Temp9am', 'Temp3pm', 'WindGustSpeed', 'WindSpeed3pm', 'Pressure9am', 'Pressure3pm'] sns.pairplot(df[num_var], kind='scatter', diag_kind='hist', palette='Rainbow') plt.show() Interpretation I have defined a variable num_var which consists of MinTemp, MaxTemp, Temp9am, Temp3pm, WindGustSpeed, WindSpeed3pm, Pressure9am and Pressure3pm variables. The above pair plot shows relationship between these variables. ","date":"2020-07-09","objectID":"/logistic-regression/:1:0","tags":["blogging","data science","machine learning","logistic regression","python"],"title":"Logistic Regression","uri":"/logistic-regression/"},{"categories":["Logistic Regression","Tutorial","Machine Learning"],"content":"Split target from features X = df.drop(['RainTomorrow'], axis=1) y = df['RainTomorrow'] # split X and y into training and testing sets X_train, X_test, y_train, y_test = train_test_split(X, y, test_size = 0.2, random_state = 42) ","date":"2020-07-09","objectID":"/logistic-regression/:2:0","tags":["blogging","data science","machine learning","logistic regression","python"],"title":"Logistic Regression","uri":"/logistic-regression/"},{"categories":["Logistic Regression","Tutorial","Machine Learning"],"content":"Feature Engineering Feature Engineering is the process of transforming raw data into useful features that help us to understand our model better and increase its predictive power. I will carry out feature engineering on different types of variables. Assumption I assume that the data are missing completely at random (MCAR). There are two methods which can be used to impute missing values. One is mean or median imputation and other one is random sample imputation. When there are outliers in the dataset, we should use median imputation. So, I will use median imputation because median imputation is robust to outliers. I will impute missing values with the appropriate statistical measures of the data, in this case median. Imputation should be done over the training set, and then propagated to the test set. It means that the statistical measures to be used to fill missing values both in train and test set, should be extracted from the train set only. This is to avoid overfitting. # impute missing values in X_train and X_test with respective column median in X_train for df1 in [X_train, X_test]: for col in numerical: col_median=X_train[col].median() df1[col].fillna(col_median, inplace=True) # check again missing values in numerical variables in X_train X_train[numerical].isnull().sum() MinTemp 0 MaxTemp 0 Rainfall 0 Evaporation 0 Sunshine 0 WindGustSpeed 0 WindSpeed9am 0 WindSpeed3pm 0 Humidity9am 0 Humidity3pm 0 Pressure9am 0 Pressure3pm 0 Cloud9am 0 Cloud3pm 0 Temp9am 0 Temp3pm 0 Year 0 Month 0 Day 0 dtype: int64 Engineering missing values in categorical variables # impute missing categorical variables with most frequent value for df2 in [X_train, X_test]: df2['WindGustDir'].fillna(X_train['WindGustDir'].mode()[0], inplace=True) df2['WindDir9am'].fillna(X_train['WindDir9am'].mode()[0], inplace=True) df2['WindDir3pm'].fillna(X_train['WindDir3pm'].mode()[0], inplace=True) df2['RainToday'].fillna(X_train['RainToday'].mode()[0], inplace=True) # check missing values in categorical variables in X_train categorical = X_train.select_dtypes(include=['object']).columns X_train[categorical].isnull().sum() Location 0 WindGustDir 0 WindDir9am 0 WindDir3pm 0 RainToday 0 dtype: int64 Engineering outliers in numerical variables We have seen that the Rainfall, Evaporation, WindSpeed9am and WindSpeed3pm columns contain outliers. I will use top-coding approach to cap maximum values and remove outliers from the above variables. def max_value(df3, variable, top): return np.where(df3[variable]\u003etop, top, df3[variable]) for df3 in [X_train, X_test]: df3['Rainfall'] = max_value(df3, 'Rainfall', 3.2) df3['Evaporation'] = max_value(df3, 'Evaporation', 21.8) df3['WindSpeed9am'] = max_value(df3, 'WindSpeed9am', 55) df3['WindSpeed3pm'] = max_value(df3, 'WindSpeed3pm', 57) Encode categorical variables encoder = ce.BinaryEncoder(cols=['RainToday']) X_train = encoder.fit_transform(X_train) X_test = encoder.transform(X_test) X_train = pd.get_dummies(X_train) X_test = pd.get_dummies(X_test) We now have training and testing set ready for model building. Before that, we should map all the feature variables onto the same scale. It is called feature scaling. I will do it as follows cols = X_train.columns scaler = MinMaxScaler() X_train = scaler.fit_transform(X_train) X_test = scaler.transform(X_test) X_train = pd.DataFrame(X_train, columns=[cols]) X_test = pd.DataFrame(X_test, columns=[cols]) Now we can finally train the logistic regression model ","date":"2020-07-09","objectID":"/logistic-regression/:3:0","tags":["blogging","data science","machine learning","logistic regression","python"],"title":"Logistic Regression","uri":"/logistic-regression/"},{"categories":["Logistic Regression","Tutorial","Machine Learning"],"content":"Modelling # instantiate the model logreg = LogisticRegression(solver='liblinear', random_state=42) # fit the model logreg.fit(X_train, y_train) LogisticRegression(random_state=42, solver='liblinear')In a Jupyter environment, please rerun this cell to show the HTML representation or trust the notebook. On GitHub, the HTML representation is unable to render, please try loading this page with nbviewer.org.LogisticRegressionLogisticRegression(random_state=42, solver='liblinear') y_pred_test = logreg.predict(X_test) predict_proba method predict_proba method gives the probabilities for the target variable(0 and 1) in this case, in array form. # probability of getting output as 0 - no rain logreg.predict_proba(X_test)[:,0] array([0.15163563, 0.703692 , 0.98254885, ..., 0.98586207, 0.9495434 , 0.95416021]) # probability of getting output as 1 - rain logreg.predict_proba(X_test)[:,1] array([0.84836437, 0.296308 , 0.01745115, ..., 0.01413793, 0.0504566 , 0.04583979]) print(f'Model accuracy score: {accuracy_score(y_test, y_pred_test):0.4f}') Model accuracy score: 0.8455 Compare the train-set and test-set accuracy Now, I will compare the train-set and test-set accuracy to check for overfitting. y_pred_train = logreg.predict(X_train) print(f'Training-set accuracy score: {accuracy_score(y_train, y_pred_train):0.4f}') Training-set accuracy score: 0.8483 The training-set accuracy score is 0.8483 while the test-set accuracy to be 0.8455. These two values are quite comparable. So, there is no question of overfitting. In Logistic Regression, we use default value of C = 1 (C is the inverse of regularization strength, regularization wasn’t discussed in this article, maybe in another article in the future). It provides good performance with approximately 85% accuracy on both the training and the test set. But the model performance on both the training and test set are very comparable. It is likely the case of underfitting. I will increase C and fit a more flexible model. # fit the Logsitic Regression model with C=100 logreg100 = LogisticRegression(C=100, solver='liblinear', random_state=42) # fit the model logreg100.fit(X_train, y_train) LogisticRegression(C=100, random_state=42, solver='liblinear')In a Jupyter environment, please rerun this cell to show the HTML representation or trust the notebook. On GitHub, the HTML representation is unable to render, please try loading this page with nbviewer.org.LogisticRegressionLogisticRegression(C=100, random_state=42, solver='liblinear') # print the scores on training and test set print(f'Training set score: {logreg100.score(X_train, y_train):.4f}') print(f'Test set score: {logreg100.score(X_test, y_test):.4f}') Training set score: 0.8488 Test set score: 0.8456 We can see that, C=100 results in higher test set accuracy and also a slightly increased training set accuracy. So, we can conclude that a more complex model should perform better. Compare model accuracy with null accuracy So, the model accuracy is 0.8501. But, we cannot say that our model is very good based on the above accuracy. We must compare it with the null accuracy. Null accuracy is the accuracy that could be achieved by always predicting the most frequent class. So, we should first check the class distribution in the test set. # check class distribution in test set y_test.value_counts() No 22098 Yes 6341 Name: RainTomorrow, dtype: int64 We can see that the occurences of most frequent class is 22067. So, we can calculate null accuracy by dividing 22067 by total number of occurences. # check null accuracy score null_accuracy = (22067/(22067+6372)) print('Null accuracy score: {0:0.4f}'. format(null_accuracy)) Null accuracy score: 0.7759 Interpretation We can see that our model accuracy score is 0.8501 but null accuracy score is 0.7759. So, we can conclude that our Logistic Regression model is doing a very good job in predicting the class labels. Now, based on the above analysis we can conclude that our classification model accuracy is very goo","date":"2020-07-09","objectID":"/logistic-regression/:4:0","tags":["blogging","data science","machine learning","logistic regression","python"],"title":"Logistic Regression","uri":"/logistic-regression/"},{"categories":["Polynomial Regression","Tutorial","Machine Learning"],"content":"All you need to know","date":"2020-05-15","objectID":"/polynomial-regression/","tags":["blogging","data science","machine learning","polynomial regression","python"],"title":"Polynomial Regression","uri":"/polynomial-regression/"},{"categories":["Polynomial Regression","Tutorial","Machine Learning"],"content":"Introduction The data we have frequently cannot be fitted linearly, and we must use a higher degree polynomial (such as a quadratic or cubic one) to be able to fit the data. When the relationship between the dependent ($Y$) and the independent ($X$) variables is curvilinear, as seen in the following figure (generated using numpy based on a quadratic equation), we can utilise a polynomial model. import pandas as pd import numpy as np import matplotlib.pyplot as plt import plotly.express as px import plotly.graph_objects as go from sklearn.linear_model import LinearRegression from sklearn.preprocessing import PolynomialFeatures import operator X = 6 * np.random.rand(200, 1) - 3 y = 0.5 * X**2 + X + 2 + np.random.randn(200, 1) fig = plt.figure(figsize=(10,8)) _ = plt.scatter(X,y,s=10) _ = plt.xlabel(\"$X$\", fontsize=16) _ = plt.ylabel(\"$y$\", rotation=0, fontsize=16) Understanding linear regression and the mathematics underlying it is necessary for this topic. You can read my previous article on Linear Regression if you aren’t familiar with it. Applying a linear regression model to this dataset first will allow us to gauge how well it will perform. model = LinearRegression() model.fit(X, y) y_pred = model.predict(X) fig = plt.figure(figsize=(10,8)) _ = plt.scatter(X, y, s=10) _ = plt.plot(X, y_pred, color='r') plt.show() The plot of the best fit line is: It is clear that the straight line is incapable to depict the data’s patterns. This is an example of underfitting (“Underfitting is a scenario in data science where a data model is unable to capture the relationship between the input and output variables accurately, generating a high error rate..\"). Computing the R2 score of the linear line gives: from sklearn.metrics import r2_score print(f\"R-Squared of the model is {r2_score(y, y_pred)}\") R-Squared of the model is 0.42763591651827204 Combatting Underfitting The complexity of the model must be increased in order to combat underfitting. ","date":"2020-05-15","objectID":"/polynomial-regression/:0:1","tags":["blogging","data science","machine learning","polynomial regression","python"],"title":"Polynomial Regression","uri":"/polynomial-regression/"},{"categories":["Polynomial Regression","Tutorial","Machine Learning"],"content":"Why Polynomial Regression? We can add powers of the original features as additional features to create a higher order equation. A linear model, $\\hat{y} = {\\alpha} + {\\beta}_1x$ can be transformed to $\\hat{y} = {\\alpha} + {\\beta}_1x + {\\beta}_2x^{2}$ Linear Model or Not? Given that the coefficients and weights assigned to the features are still linear, this model is still regarded as linear. $x^{2}$ is still only a feature. But the curve we are trying to fit is quadratic in nature. What we are only doing here is adding powers of each feature as new features (interactions between multiple features can also be added as well depending on the implementation), then simply train a linear model on this extended set of features. This is the essence of Polynomial Regression (details later 😉) The scikit-Learn PolynomialFeatures class can be used to transform the original features into their higher order terms. Then we can train a linear model with those new generated features. Numpy also offers a polynomial regression implementation using numpy.polyfit (check my github for usage). polynomial_features= PolynomialFeatures(degree=2) x_poly = polynomial_features.fit_transform(X) model = LinearRegression() model.fit(x_poly, y) y_poly_pred = model.predict(x_poly) r2 = r2_score(y,y_poly_pred) sort_axis = operator.itemgetter(0) sorted_zip = sorted(zip(X,y_poly_pred), key=sort_axis) x, y_poly_pred = zip(*sorted_zip) fig = plt.figure(figsize=(10,8)) _ = plt.scatter(X, y, s=10) _ = plt.plot(x, y_poly_pred, color='r') plt.show() Fitting a linear regression model on the transformed features gives the following plot. The figure makes it quite evident that the quadratic curve can fit the data more accurately than the linear line. Calculating the quadratic plot’s R2 score results in: print(f\"R-Squared of the model is {r2}\") R-Squared of the model is 0.8242378566950601 Which is a great improvement from the previous R2 score When we try to fit a curve with degree 10 to the data, we can observe that it “passes through” more data points than the quadratic and linear plots. polynomial_features= PolynomialFeatures(degree=10) x_poly = polynomial_features.fit_transform(X) model = LinearRegression() model.fit(x_poly, y) y_poly_pred = model.predict(x_poly) r2 = r2_score(y,y_poly_pred) sort_axis = operator.itemgetter(0) sorted_zip = sorted(zip(X,y_poly_pred), key=sort_axis) x, y_poly_pred = zip(*sorted_zip) fig = plt.figure(figsize=(10,8)) _ = plt.scatter(X, y, s=10) _ = plt.plot(x, y_poly_pred, color='r') plt.show() print(f\"R-Squared of the model is {r2}\") R-Squared of the model is 0.831777739222978 We can observe that increasing the degree to 30 causes the curve to pass through more data points. polynomial_features= PolynomialFeatures(degree=30) x_poly = polynomial_features.fit_transform(X) model = LinearRegression() model.fit(x_poly, y) y_poly_pred30 = model.predict(x_poly) r2 = r2_score(y,y_poly_pred30) sort_axis = operator.itemgetter(0) sorted_zip = sorted(zip(X,y_poly_pred30), key=sort_axis) x, y_poly_pred30 = zip(*sorted_zip) fig = plt.figure(figsize=(10,8)) _ = plt.scatter(X, y, s=10) _ = plt.plot(x, y_poly_pred30, color='r') plt.show() print(f\"R-Squared of the model is {r2}\") R-Squared of the model is 0.7419383093794893 For degree 30, the model also accounts for noise in the data. This is an example of overfitting ( “Overfitting is a concept in data science, which occurs when a statistical model fits exactly against its training data. When this happens, the algorithm unfortunately cannot perform accurately against unseen data, defeating its purpose.” ). Despite the fact that this model passes through many of the data, it will fail to generalise on unseen data, as observed on the decrease in R2 score. Combatting Overfitting To avoid overfitting, we may either increase the number of training samples so that the algorithm does not learn the noise in the system and can become more generalised (adding more data can potentially be an issue if the data is itsel","date":"2020-05-15","objectID":"/polynomial-regression/:0:2","tags":["blogging","data science","machine learning","polynomial regression","python"],"title":"Polynomial Regression","uri":"/polynomial-regression/"},{"categories":["Polynomial Regression","Tutorial","Machine Learning"],"content":"The Bias vs Variance Trade-Off Bias refers to the error due to the model’s simplistic assumptions in fitting the data. A high bias means that the model is unable to capture the patterns in the data and this results in underfitting. Variance refers to the error due to the complex model trying to fit the data. High variance means the model passes through most of the data points and it results in overfitting the data. The following figure summarizes this concept: The graph below shows that as model complexity increases, bias decreases and variance increases, and vice versa. A machine learning model should ideally have low variance and bias. However, it is nearly difficult to have both. As a result, a trade-off is made in order to produce a good model that performs well on both train and unseen data. Source: Bias-Variance Tradeoff ","date":"2020-05-15","objectID":"/polynomial-regression/:0:3","tags":["blogging","data science","machine learning","polynomial regression","python"],"title":"Polynomial Regression","uri":"/polynomial-regression/"},{"categories":["Polynomial Regression","Tutorial","Machine Learning"],"content":"Polynomial Fitting Details Rank of a matrix Suppose we are given a $mxn$ matrix $A$ with its columns to be $[ a_1, a_2, a_3 ……a_n ]$. The column $a_i$ is called linearly dependent if we can write it as a linear combination of other columns i.e. $a_i = w_1a_1 + w_2a_2 + ……. + w_{i-1}a_{i-1} + w_{i+1}a_{i+1} +….. + w_{n}a_{n}$ where at least one $w_{i}$ is non-zero. Then we define the rank of the matrix as the number of independent columns in that matrix. $Rank(A)$ = number of independent columns in $A$. However there is another interesting property that the number of linearly independent columns is equal to the number of independent rows in a matrix (proof). Hence $Rank(A) ≤ min(m, n)$. A matrix is called full rank if $Rank(A) = min(m, n)$ and is called rank deficient if $Rank(A) \u003c min(m, n)$. Pseudo-Inverse of a matrix An $nxn$ square matrix $A$ has an inverse $A^{-1}$ if and only if $A$ is a full rank matrix. However a rectangular $mxn$ matrix $A$ does not have an inverse. If $A^{T}$ denotes the transpose of matrix $A$ then $A^{T}A$ is a square matrix and Rank of $(A^{T}A)$ = $Rank (A)$ (proof). Therefore if $A$ is a full-rank matrix then the inverse of $A^{T}A$ exists. And $(A^{T}A)^{-1}A^{T}$ is called the pseudo-inverse of $A$. We’ll see soon why it is called so. Details As discussed earlier, in polynomial regression, the original features are converted into polynomial features of required degree $(2,3,..,n)$ and then modeled using a linear model. Suppose we are given $n$ data points $pi = [ x_{i1} ,x_{i2} ,……, x_{im} ]^{T} , 1 ≤ i ≤ n$ , and their corresponding values $vi$. Here $m$ denotes the number of features that we are using in our polynomial model. Our goal is to find a nonlinear function $f$ that minimizes the error Hence $f$ is nonlinear over $pi$. So let’s take an example of a quadratic function i.e. with $n$ data points and 2 features. Then the function would be The objective is to learn the coefficients. Hence we have $n$ points $pi$ and their corresponding values $vi$; we have to minimize For each data point we can write equations as Hence we can form the following matrix equation $$Da = v$$ where However the equation is nonlinear with respect to the data points $pi$, it is linear with respect to the coefficients $a$. So, we can solve for a using the linear least square method. We have $$Da = v$$ multiply $D^{T}$ on both sides $$D^{T}Da = D^{T}v$$ Suppose $D$ has a full rank, that is when the columns in $D$ are linearly independent, then $D^{T}D$ has an inverse.Therefore $$(D^{T}D)^{-1}(D^{T}D)a = (D^{T}D)^{-1}D^{T}v$$ We now have $$a = (D^{T}D)^{-1}D^{T}v$$ Comparing it with $Da = v$, we can see that $(D^{T}D)^{-1}D^{T}$ acts like the inverse of $D$. So it is called the pseudo-inverse of $D$. The above used quadratic polynomial function can be generalised to a polynomial function of order or degree $m$. Thank you for reading and I hope now that you are clear with the working of polynomial regression and the mathematics behind. I have used polynomial regression on the Covid-19 data and wrote an article about it, you can read it here. Also check the github repo for the complete code. ","date":"2020-05-15","objectID":"/polynomial-regression/:0:4","tags":["blogging","data science","machine learning","polynomial regression","python"],"title":"Polynomial Regression","uri":"/polynomial-regression/"},{"categories":["Data Analysis","Interactive","Visualisation","Linear Regression","Machine Learning"],"content":"A deep dive into the Coronavirus data","date":"2020-03-28","objectID":"/covid19-interactive-analysis/","tags":["blogging","data science","machine learning","covid-19"],"title":"COVID-19: An Interactive Analysis","uri":"/covid19-interactive-analysis/"},{"categories":["Data Analysis","Interactive","Visualisation","Linear Regression","Machine Learning"],"content":" A new virus has plauged us and caused turmoil in the world. This virus has caused shut-downs, lockdowns and in the worst-case will unfortunately cause deaths. It is our job as responsible citizens to do our best to stop it from further spreading, and what better way than for us data scientists to dive deep into the data (of course while wearing masks and keeping the safe distance). So lets dive in. ","date":"2020-03-28","objectID":"/covid19-interactive-analysis/:0:0","tags":["blogging","data science","machine learning","covid-19"],"title":"COVID-19: An Interactive Analysis","uri":"/covid19-interactive-analysis/"},{"categories":["Data Analysis","Interactive","Visualisation","Linear Regression","Machine Learning"],"content":"Introduction The SARS-CoV-2 virus causes Coronavirus Disease (COVID-19), an infectious respiratory disease. The majority of those infected with the virus will have mild to moderate respiratory symptoms and will recover without the need for medical attention. Some, on the other hand, will become critically unwell and require medical assistance. Serious sickness is more likely to strike the elderly and those with underlying medical disorders such as cardiovascular disease, diabetes, chronic respiratory disease, or cancer. COVID-19 can make anyone sick and cause them to get very ill or die at any age. But how does the virus spread? Coughing, sneezing, and talking are the most common ways for the virus to spread through small droplets. Although the droplets are not normally airborne, persons who are in close proximity to them may inhale them and become infected. By contacting a contaminated surface and subsequently touching their face, people can become sick. Aerosols that can stay suspended in the air for prolonged periods of time in confined places may also be a source of transmission. It is most contagious in the first three days after symptoms develop, but it can also spread before symptoms appear and from asymptomatic people. Which strongly explains the value of wearing well fitted masks and as further illustrated in the GIF below. GIF Source: Infrared video shows the risks of airborne coronavirus spread | Visual Forensics So if we ask ourselves how can we prevent COVID-19 from spreading, we’ll find these main precautions to take: Keep a safe distance away from somebody coughing or sneezing. When physical separation isn’t possible, wear a mask. Seek medical help if you have a fever, cough, or difficulty breathing. If you’re sick, stay at home. Hands should be washed frequently. Use soap and water or an alcohol-based hand rub to clean your hands. Keep your hands away from your eyes, nose, and mouth. When you cough or sneeze, cover your nose and mouth with your bent elbow or a tissue. How is the virus detected? Real-time reverse transcription polymerase chain reaction (rRT-PCR) from a nasopharyngeal swab is the usual method of diagnosis. Although chest CT imaging may be useful for diagnosis in patients with a strong suspicion of infection based on symptoms and risk factors, it is not recommended for routine use screening (Wikipedia), which may present an option to utilize computer vision for example by using convolutional neural networks to detect the virus in CT image scans, we’ll explore this another time in a different article. ","date":"2020-03-28","objectID":"/covid19-interactive-analysis/:1:0","tags":["blogging","data science","machine learning","covid-19"],"title":"COVID-19: An Interactive Analysis","uri":"/covid19-interactive-analysis/"},{"categories":["Data Analysis","Interactive","Visualisation","Linear Regression","Machine Learning"],"content":"Diving Deep into the data All these previous precautions mentioned are of tremendous importance to stop the virus from further spreading but these won’t allow us to study more concisely where it spreads, why it spreads in areas more than others and how we can flatten the curve, as they are proactive measures, we are trying to analyze the historical (even though the virus is still fairly young) data through reactive measures of data analysis and machine learning, of course proactive (unsupervised learning) measures can also be deployed. That’s where data analysis comes into play. I dug deep into the data and all the accompaying code in this article can be found in this Github repository: Covid-19-Analysis. The data is provided by John Hopkins University, it is available in their Github repo. The data is updated daily. I will also be using data from Our World In Data and acaps for further data exploration. Lets start by first importing all required libraries. And setting some default settings import pandas as pd import numpy as np import itertools import os import warnings from itertools import tee warnings.filterwarnings('ignore') import plotly.express as px import plotly.graph_objects as go from plotly.subplots import make_subplots import plotly.io as pio import plotly.offline as py import ipywidgets as widgets py.init_notebook_mode() pio.renderers.default = \"notebook\" pd.options.plotting.backend = \"plotly\" pd.options.display.max_rows = 20 from sklearn.linear_model import LinearRegression from sklearn.preprocessing import PolynomialFeatures from sklearn.metrics import r2_score, mean_absolute_error, mean_squared_error from sklearn.model_selection import train_test_split #from countryinfo import CountryInfo #Populations not up to date import pypopulation import pycountry I’ll be using plotly for interactive plotting. ipywidgets for interactive user data filtering and selection. Pandas and numpy for data manipulation. scikit-learn for machine learning and further corresponding libraries for other utilities. We’ll then load the datasets using Pandas straight from the source URL, because in this way everytime the code is ran it will have the most up to date data, rather than a downloaded Excel or CSV file. # Only use the columns we need cols = ['iso_code','continent','location','date' ,'total_cases','new_cases','total_deaths', 'new_deaths','total_cases_per_million', 'new_cases_per_million','total_deaths_per_million', 'new_deaths_per_million','new_tests', 'total_tests','total_tests_per_thousand', 'new_tests_per_thousand','new_tests_smoothed', 'new_tests_smoothed_per_thousand', 'tests_units','stringency_index', 'population','population_density', 'median_age','aged_65_older','aged_70_older', 'gdp_per_capita','extreme_poverty', 'cardiovasc_death_rate','diabetes_prevalence', 'female_smokers','male_smokers', 'handwashing_facilities', 'hospital_beds_per_thousand','life_expectancy'] df_stats = pd.read_csv('https://covid.ourworldindata.org/data/owid-covid-data.csv',delimiter=',') df_stats = df_stats[cols] df_measures = pd.read_excel('https://www.acaps.org/sites/acaps/files/resources/files/acaps_covid19_government_measures_dataset_0.xlsx', header=0,sheet_name='Dataset') df_confirmed = pd.read_csv('https://raw.githubusercontent.com/CSSEGISandData/COVID-19/master/csse_covid_19_data/csse_covid_19_time_series/time_series_covid19_confirmed_global.csv') df_deaths = pd.read_csv('https://raw.githubusercontent.com/CSSEGISandData/COVID-19/master/csse_covid_19_data/csse_covid_19_time_series/time_series_covid19_deaths_global.csv') df_recoveries = pd.read_csv('https://raw.githubusercontent.com/CSSEGISandData/COVID-19/master/csse_covid_19_data/csse_covid_19_time_series/time_series_covid19_recovered_global.csv') Shape for Statistics DataFrame: (167554, 34) Shape for Measures DataFrame: (23923, 18) Shape for Confirmed DataFrame: (284, 783) Shape for Deaths DataFrame: (284, 783) Shape for Recovories DataFrame: (269, 783) After loading the data and printing t","date":"2020-03-28","objectID":"/covid19-interactive-analysis/:2:0","tags":["blogging","data science","machine learning","covid-19"],"title":"COVID-19: An Interactive Analysis","uri":"/covid19-interactive-analysis/"},{"categories":["Linear Regression","Tutorial","Machine Learning"],"content":"All you need to know","date":"2020-03-10","objectID":"/linear-regression-all-you-need-to-know/","tags":["blogging","data science","machine learning","linear regression","python"],"title":"Linear Regression","uri":"/linear-regression-all-you-need-to-know/"},{"categories":["Linear Regression","Tutorial","Machine Learning"],"content":"What a better way to start my blogging journey, than with one of the most fundamental statistical learning techniques, Linear Regression. A straightforward method for supervised learning - supervised learning is the process of training a model on data where the outcome is known before applying it to data where the outcome is unknown -, learning linear regression also helps to understand the overall process of what supervised learning looks like. Linear regression, in particular, is a powerful tool for predicting a quantitative response. It's been around for a while and is the subject of a slew of textbooks. Linear Regression is part of the Generalized Linear Models family (GLM for short). Despite the fact that it may appear tedious in comparison to some of the more current statistical learning approaches, linear regression remains an effective and extensively used statistical learning method. It also provides as a useful starting point for emerging approaches. Many fancy statistical learning methods can be thought of as extensions or generalizations of linear regression. As a result, the necessity of mastering linear regression before moving on to more advanced learning approaches cannot be emphasized. The response to the question \"Is the variable $X$ associated with a variable $Y$, and if so, what is the relationship, and can we use it to predict Y?\" is perhaps the most prevalent goal in statistics and linear regression tries to answer that, it does this based on linear relationships between the independent ($X$) and dependent ($Y$) variables. Simple linear regression creates a model of the relationship between the magnitudes of two variables—for example, as X increases, Y increases as well. Alternatively, when X increases, Y decreases. I've used the term simple here because we are only talking about one variable X, but instead of one variable X, we can of course use multiple predictor variables $ X_{1}...X_{n} $, which is often termed Multiple Linear Regression or just simply Linear Regression. I assure you that I have a multitude of examples and explanations that go through all of the finer points of linear regression. But first, let's go through the fundamental concepts. ","date":"2020-03-10","objectID":"/linear-regression-all-you-need-to-know/:0:0","tags":["blogging","data science","machine learning","linear regression","python"],"title":"Linear Regression","uri":"/linear-regression-all-you-need-to-know/"},{"categories":["Linear Regression","Tutorial","Machine Learning"],"content":"The fundamental concepts behind linear regression The first step in linear regression is to fit a line to the data using least squares The second step is to compute R2 Finally, compute the p-value for the computed R squared in the previous step The first concept we are going to tackle is fitting a line to the data, what exactly does that mean and how can we do it? To effectively explain that we are going to need some data. I will be using the fish market data from Kaggle which is available here. The dataset contains sales records for seven common fish species seen in fish markets. Some of the features (columns) in dataset are: Species, Weight, Different Lengths, Height and Width. We’ll be using it to estimate the weight of the fish, as we are trying to explain linear regression we’ll first use only one feature to predict the weight, the height (simple linear regression) We’ll first load the dataset using pandas read_csv: df = pd.read_csv(\"data/Fish.csv\") All code in this article can be found in my Github in this repository Now back to our first concept, fitting a line to the data, what does that mean? Fitting a line to the data To clearly explain this concept let’s first get only one species of fish, in this example we’ll use Perch: df_perch = df[df.Species == 'Perch'] We’ll then simply create a scatter plot of Weight vs. Height. fig = px.scatter(df_perch, x='Height', y='Weight') fig.show() And then we’ll plot a horizontal line across the data, at the average weight (our target variable). mean_val= df_perch.Weight.mean() fig = fig.add_hline(y = mean_val,row= None, col = None) fig.show() Then we calculate the difference between the actual values, the dots representing the weights in the figure, and the line (the mean value). This can be thought of as the distance between them (if you would like to think geometrically). These distances are also called the residuals. Here are the residuals plotted. for weight,height in zip(df_perch.Weight,df_perch.Height): fig.add_shape(type='line',x0=height,x1=height,y0=weight,y1=mean_val,line=dict(width=1,dash='dash',color='red')) fig.show() Then we'll square each distance (residual) from the line to the data and sum them all up. We square the residuals so that the negative and positive residuals don't cancel each other out. residuals_squared = (df_perch.Weight - mean_val)**2 residuals_squared.sum() We get a value of 6646094.253571428. That’s a very large number, but we don’t want that we want it to be as low as possible, and how can we do that? That’s the next step. Third we rotate and/or shift the line a little bit to be able to decrease this sum of squared distances or residuals to its lowest possible value, that is where the name least squares (or ordinary least squares) comes from. To do that we need to understand what exactly a line is mathematically. You probably remember from linear algebra that a line is just this equation $ y = mx +b $, where $m$ is the slope of the line $b$ is the y-intercept, $x$ is the x-axis value and $y$ is the y-axis value. Well to rotate the line we need to iteratively - or mathematically - adjust the y-intercept ($b$) and the slope ($m$) so that the sum of the squared residuals - the error - is the lowest. In linear regression the equation is usually expressed in a different way like so: $\\hat{y} = {\\alpha} + {\\beta}x$, where $ {\\alpha} $ is the y-intercept (sometimes also written as $ {\\beta}_0 $) and $ {\\beta} $ is the slope. In simple linear regression there is only one independent variable - feature - and therefore only one slope - or coefficient -, but in many cases we have many different features that we would like to use in our equation so for every feature $X_n$ added we add its coefficient $ {\\beta}_n$, to be estimated with the y-intercept. In general, such a relationship may not hold perfectly for the mostly unobserved population of values of the feature and target variables; these unobserved variations from the above equation are referred to as rand","date":"2020-03-10","objectID":"/linear-regression-all-you-need-to-know/:0:1","tags":["blogging","data science","machine learning","linear regression","python"],"title":"Linear Regression","uri":"/linear-regression-all-you-need-to-know/"},{"categories":["General"],"content":"The beginning of sharing my journey publicly","date":"2020-03-04","objectID":"/why-i-started-blogging/","tags":["blogging","data science","machine learning"],"title":"Why I started Blogging","uri":"/why-i-started-blogging/"},{"categories":["General"],"content":"I’ve been studying machine learning, data analysis and all-stuff data for almost a year now. It’s been an exciting journey, I got to talk to interesting people, work on meaningful projects but most importantly learn, which is really my favourite activity. Plus, my passion for data and being able to use it in worthwhile ways, that will help others grew significantly. I already had an impulse to patterns, numbers, math and reasoning which definitely helped shape my ambition in learning machine learning, data analysis and pursuing a career in data science, not because it was labelled “The Sexiest Job Of The 21st Century” by the Harvard Business Review back in 2012. After this small but growing journey, I decided to document it, in the form of blog posts. I worked on several projects so I will be talking about them and sharing them. I tried and still try to understand different algorithms and techniques in my own way, so I will write about them in my own way of thinking. I will also be working on new projects, and I’ll try my best to share them as well. There are other several reasons why I decided to start my own blog, here are some of them: It can help others. Others may benefit from the way I went about several of my own projects and my own way of understanding different concepts. It helps me get feedback on my work. While my blog posts can help others, I am not perfect and I might have gotten something wrong and any feedback from others can help me better myself. It’s like a portfolio/resume of my work but even better! Because not only do I showcase my skills I can get directly contacted for job offers. I’ve used my previous projects with my previous employers to land several jobs. It helps me learn. Organizing information always aids me in formulating my own thoughts. One of the ways to tell if I understand something is to explain it to someone, and I do that all the time with others, but now just only in blog posts. It can also help me get to know others and even collaborate. I’ve made a summary on my previous work with the help of my projects, and notes. I’ll be using this summary to help me write these blog posts and maybe even enhance/update my previous work, and I advise anyone in the field of data science to try and do the same thing, there’s really nothing negative that can come from it, it doesn’t have to be an article a day, or even an article a week, you can do it at your own pace and build it up slowly. I will be writing about: Projects I have worked on Data analysis and business intelligence: from data cleaning, pre-processing, visualization, interactivity, applied statistics and data analysis tools. Machine Learning Algorithms: Regression, Classification, Clustering, etc. Deep Learning: Backpropagation, Activation Functions, Computer Vision, Natural Language Processing, etc. And who knows there might be new topics I would like to write about, only time will tell 😉. I hope I got your attention, and you are willing to embark with me in my journey. I am super excited to write, code and share all the work I have been working on and will be working on. You can of course subscribe to my feed and get all the latest blog posts as soon as they are uploaded to my website. I also write in Medium here: @arebi.mohamed59. All my other social links such as GitHub and LinkedIn are to be found at the bottom of this page. Thank you for reading and see you on soon in the next article. Stay Safe! ","date":"2020-03-04","objectID":"/why-i-started-blogging/:0:0","tags":["blogging","data science","machine learning"],"title":"Why I started Blogging","uri":"/why-i-started-blogging/"},{"categories":null,"content":" Here are some Projects I have worked on and currently working on: Project Name Description Year Status Covid-19 Interactive Data Analysis In-depth analysis of the Covid-19 data. Findings presented in interactive charts. The charts are deployed on both Binder and Heroku. Blog post that talks about the project can be found here and accompanying GitHub Repo 2020 Done✔️ ","date":"2020-03-03","objectID":"/projects/my-projects/:0:0","tags":null,"title":"Projects","uri":"/projects/my-projects/"},{"categories":null,"content":" MOHAMMED AREBI Profile A resourceful and extremely motivated data scientist with a proven track record of solving difficult business problems. I like work on meaningful projects and build valuable applications in the area of machine learning. Actively Building. Always Learning. Work Experience ","date":"2020-03-03","objectID":"/resume/my-resume/:0:0","tags":["Resume"],"title":"Resume","uri":"/resume/my-resume/"},{"categories":null,"content":"TDK-Micronas Freiburg, Baden-Württemberg Data Scientist Intern September 2021 to March 2022 Analyzing semi-conductor defect and test data using Python on Jupyter and its subsequent libraries (Pandas, NumPy, Plotly, SciPy, statsmodels, sci-kit learn, Dash, Keras, etc.) to extract insight on defects and production processes using advanced statistical methods and machine learning algorithms. Interactive dashboard creation and maintenance using Jupyter, Plotly and ipython widgets for engineers to visualize and analyze data. Enhancing and updating several data analysis notebooks using several machine learning algorithms. Working with Hadoop, Spark, and SQL to query data for analysis and cleaning ABAP Customization on the SAP system for data transfer from SAP to Hadoop and for data manipulation Collaboration with the R\u0026D department to automate chart extraction to several PowerPoint slides using python-pptx library and ipython widgets for interactivity. Adding offset calculations for several tests using floating point arithmetic. Developing further ETL functions from Hadoop to Python pandas. Internship Certificate Internship Certificate is in German, as the company is based in Germany. If a translation is required please write me. ","date":"2020-03-03","objectID":"/resume/my-resume/:0:1","tags":["Resume"],"title":"Resume","uri":"/resume/my-resume/"},{"categories":null,"content":"Furtwangen University Furtwangen, Baden-Württemberg Professor Assistant October 2020 to February 2021 Assisting IBS program professors with the hybrid technology Tutoring for IBS students Contact with students online to keep the lecture as smooth as possible, forwarding all inquiries to the professor face-to-face. Organizing events for IBS students. Semester Representative/Speaker (Semester Sprecher) ","date":"2020-03-03","objectID":"/resume/my-resume/:0:2","tags":["Resume"],"title":"Resume","uri":"/resume/my-resume/"},{"categories":null,"content":"Moodio Ltd Tripoli, Libya Data Analyst Intern January 2019 to July 2019 Data analyst intern, creating dashboards and reports on Power BI. Presentation to the high-level management. Writing SQL statements for data entry and retrieval. Analyzing data with R and Python. ","date":"2020-03-03","objectID":"/resume/my-resume/:0:3","tags":["Resume"],"title":"Resume","uri":"/resume/my-resume/"},{"categories":null,"content":"Almaaref Private School Tripoli, Libya Data Manager Intern June 2018 to December 2018 Managing the school database on MySQL, running SQL queries on several datasets, creating, maintaining tables, ERM models and data entry and retrieval. ","date":"2020-03-03","objectID":"/resume/my-resume/:0:4","tags":["Resume"],"title":"Resume","uri":"/resume/my-resume/"},{"categories":null,"content":"Talent Center Tripoli, Libya English Teacher October 2017 to May 2018 Teaching Elementary, Pre-Intermediate and Intermediate English at Talent Center for training and languages. (Oxford English File Curriculum). ","date":"2020-03-03","objectID":"/resume/my-resume/:0:5","tags":["Resume"],"title":"Resume","uri":"/resume/my-resume/"},{"categories":null,"content":"Sofrajee Tripoli, Libya Delivery Driver July 2017 to August 2017 Delivery guy for Sofrajee (food delivery service) , delivering all kinds of foods and drinks to all places in Tripoli. Handled arrangements with restaurants and customers. Education ","date":"2020-03-03","objectID":"/resume/my-resume/:0:6","tags":["Resume"],"title":"Resume","uri":"/resume/my-resume/"},{"categories":null,"content":"B.Sc. International Business Information Systems (IBS), Data Science and AI Specialization March 2020 to July 2023 Furtwangen University of Applied Sciences Bachelor of Science planned to be achieved: 07/2023 ","date":"2020-03-03","objectID":"/resume/my-resume/:0:7","tags":["Resume"],"title":"Resume","uri":"/resume/my-resume/"},{"categories":null,"content":"Irish Leaving Certificate September 2014 to July 2017 International School Of Martyrs Knowledge And Skills Technical skills Programming: Python, SQL, HTML, CSS, Java Database Knowledge: MySQL ML \u0026 Data Science: TensorFlow, PyTorch, Pandas, scikit-learn, Others.. Data Literacy: Data Analysis, Applied Statistics Cloud Technologies: Google Cloud Platform Data Visualization: Plotly, Power BI Social skills Teamwork, Strong communication skills, Teaching skills, Active Listening. Organizational skills Time management, Design Thinking, Analytical Thinking, Problem Solving, Highly Organized, Adaptability, Continuous Learning Orientation. Languages Arabic (Native) English (C2) German (B1) Areas of interest Data Science Data Analytics Data Visualisation Big Data Artificial Intelligence Blogging Awards And Certificates International School Of Martyrs Tripoli, Libya - “Principal’s List” for excellent performance Awards AXELOS - ITIL 4 Foundation LearnPowerBI - Microsoft Power BI LinkedIn Learning - Master Python for Data Science Additional Information And Extracurricular Activity Organized bake sales and bazars in my senior year and lead the student/teacher union. Background on HTML and flash. Participated in the Libyan afforestation campaign planting trees in several Libyan cities. Helped organize and coordinate with the school to carry out safety drills. Tutored younger students biology and physics in school for a few weeks. Participated in the world youth day in Libya, helping with preparation and activities during the event. Volunteering in a robotics event in Tripoli, Libya helping explain the main concept to visitors. Conducted a seminar at the Libyan Academy in Janzour with Talent center regarding English language history and culture. Volunteered as a coordinator at the annual event by ‘I am Tawfik’ to raise money for orphans. Design Thinking and Problem-Solving Workshops with Professor Wolfgang Grather Online courses on Agile Management and Leadership ","date":"2020-03-03","objectID":"/resume/my-resume/:0:8","tags":["Resume"],"title":"Resume","uri":"/resume/my-resume/"},{"categories":null,"content":" I LOVE DATA! From a very early age I’ve been a problem solver. I was that kid who would take part in anything to see how it worked, tried to figure out the problem and find ways to solve it, I was very curious but driven as well. I grew up with this trait and other similar traits one of them being analytical, which shaped my ambitions today in being a data analyst/scientist and anything related to that field. I was able to gain good experience in internships and projects (see Projects Page), where I learned skills like Python, Machine Learning, Statistics and calculus, SQL and Power BI. I am currently studying Data Science and Machine Learning at the Furtwangen University of Applied Sciences I am passionate about innovation, and using data science to help companies and communities thrive. I’m a data-driven and insightful student who is passionate about growing his skillset and working on meaningful projects. If I’m not cleaning data, understanding data, or pivoting tables of data, I’m working out, watching documentaries, playing football, hanging out with friends, and sipping on apple juice (Love that too). Specialties: Data Wrangling/Cleaning, Machine Learning, Python (Pandas, sci-kit learn, Tensorflow, Plotly, etc.), SQL and Microsoft Power BI ","date":"2020-03-02","objectID":"/about/about-me/:0:0","tags":null,"title":"About Me","uri":"/about/about-me/"}]